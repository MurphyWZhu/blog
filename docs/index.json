[{"content":"线程 使用spawn创建新线程\nuse std::thread; use std::time::Duration; fn main() { thread::spawn(|| { for i in 1..10 { println!(\u0026#34;hi number {} from the spawned thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5 { println!(\u0026#34;hi number {} from the main thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } } 程序会输出\nhi number 1 from the main thread! hi number 1 from the spawned thread! hi number 2 from the main thread! hi number 2 from the spawned thread! hi number 3 from the main thread! hi number 3 from the spawned thread! hi number 4 from the main thread! hi number 4 from the spawned thread! hi number 5 from the spawned thread! 这里spawn的线程到4就结束了，因为main线程提前结束了\n使用join等待所有线程结束 use std::thread; use std::time::Duration; fn main() { let handle = thread::spawn(|| { for i in 1..10 { println!(\u0026#34;hi number {} from the spawned thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5 { println!(\u0026#34;hi number {} from the main thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } handle.join().unwrap(); } 大致会产生如下输出\nhi number 1 from the main thread! hi number 2 from the main thread! hi number 1 from the spawned thread! hi number 3 from the main thread! hi number 2 from the spawned thread! hi number 4 from the main thread! hi number 3 from the spawned thread! hi number 4 from the spawned thread! hi number 5 from the spawned thread! hi number 6 from the spawned thread! hi number 7 from the spawned thread! hi number 8 from the spawned thread! hi number 9 from the spawned thread! 线程与move闭包 闭包可以使用环境中的变量\n下面代码无法编译，因为不知道v是否一直有效\nuse std::thread; fn main() { let v = vec![1, 2, 3]; let handle = thread::spawn(|| { println!(\u0026#34;Here\u0026#39;s a vector: {:?}\u0026#34;, v); }); handle.join().unwrap(); } 可以使用move获取v的所有权来解决，保证v不会在线程结束前失效\nuse std::thread; fn main() { let v = vec![1, 2, 3]; let handle = thread::spawn(move || { println!(\u0026#34;Here\u0026#39;s a vector: {:?}\u0026#34;, v); }); handle.join().unwrap(); }  消息传递 rust是通过通道来传递消息的，通道有两部分组成，一部分是发送者，一部分是接收者\n创建通道\nuse std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel();//返回一个元组，tx是发送者，rx是接收者 } 发送消息 use std::thread; use std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); thread::spawn(move || { let val = String::from(\u0026#34;hi\u0026#34;); tx.send(val).unwrap(); }); } 接收消息 接收消息有两种方式，recv和try_recv，recv会阻塞线程，而try_recv不会\nuse std::thread; use std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); thread::spawn(move || { let val = String::from(\u0026#34;hi\u0026#34;); tx.send(val).unwrap(); }); let received = rx.recv().unwrap(); println!(\u0026#34;Got: {}\u0026#34;, received); } 程序会输出\nGot: hi 通道与所有权转移 发送消息后所有权就没有了，再使用变量会出错\nuse std::thread; use std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); thread::spawn(move || { let val = String::from(\u0026#34;hi\u0026#34;); tx.send(val).unwrap(); println!(\u0026#34;val is {}\u0026#34;, val);//错误  }); let received = rx.recv().unwrap(); println!(\u0026#34;Got: {}\u0026#34;, received); } 通过克隆发送者来创建多个生产者 use std::thread; use std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); let tx1 = tx.clone(); thread::spawn(move || { let vals = vec![ String::from(\u0026#34;hi\u0026#34;), String::from(\u0026#34;from\u0026#34;), String::from(\u0026#34;the\u0026#34;), String::from(\u0026#34;thread\u0026#34;), ]; for val in vals { tx1.send(val).unwrap(); thread::sleep(Duration::from_secs(1)); } }); thread::spawn(move || { let vals = vec![ String::from(\u0026#34;more\u0026#34;), String::from(\u0026#34;messages\u0026#34;), String::from(\u0026#34;for\u0026#34;), String::from(\u0026#34;you\u0026#34;), ]; for val in vals { tx.send(val).unwrap(); thread::sleep(Duration::from_secs(1)); } }); for received in rx { println!(\u0026#34;Got: {}\u0026#34;, received); } }  共享状态 互斥器 互斥器在任何时候，只允许一个线程访问，为了访问互斥器中的数据，线程首先需要通过获取互斥器的锁\n在单线程上下文使用互斥器\nuse std::sync::Mutex; fn main() { let m = Mutex::new(5); { let mut num = m.lock().unwrap(); *num = 6; } println!(\u0026#34;m = {:?}\u0026#34;, m);//输出6 } 使用lock()来获取锁，当一个线程获取锁后，其他线程就无法在获取了，会产生panic\n在线程间共享Mutex\u0026lt;T\u0026gt; 尝试使用mutex在多个线程间共享值\nuse std::sync::Mutex; use std::thread; fn main() { let counter = Mutex::new(0); let mut handles = vec![]; for _ in 0..10 { let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap();//等待每个线程结束  } println!(\u0026#34;Result: {}\u0026#34;, *counter.lock().unwrap()); } 会出现如下错误\nerror[E0382]: use of moved value: `counter` --\u0026gt; smart_pointers/src/main.rs:9:36 | 5 | let counter = Mutex::new(0); | ------- move occurs because `counter` has type `Mutex\u0026lt;i32\u0026gt;`, which does not implement the `Copy` trait ... 9 | let handle = thread::spawn(move || { | ^^^^^^^ value moved into closure here, in previous iteration of loop 10 | let mut num = counter.lock().unwrap(); | ------- use occurs due to use in closure 编译器告诉我们counter被移动了，不能在多个线程中使用\n那如果使用之前的Rc\u0026lt;T\u0026gt;来创建引用计数的值，以便拥有多个所有者\nuse std::rc::Rc; use std::sync::Mutex; use std::thread; fn main() { let counter = Rc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Rc::clone(\u0026amp;counter); let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\u0026#34;Result: {}\u0026#34;, *counter.lock().unwrap()); } 不幸的是这样也不行，编译器会告诉你不安全\n不过还有一种Arc\u0026lt;T\u0026gt;可以安全的实现这个功能\nuse std::sync::{Mutex, Arc}; use std::thread; use std::rc::Rc; fn main() { let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Arc::clone(\u0026amp;counter); let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap();//等待每个线程结束  } println!(\u0026#34;Result: {}\u0026#34;, *counter.lock().unwrap()); } 程序终于能够成功运行，并输出如下内容\nResult: 10  使用Sync和Send trait的可扩展并发\n","permalink":"https://murphywzhu.github.io/blog/posts/rust-11/","summary":"线程 使用spawn创建新线程\nuse std::thread; use std::time::Duration; fn main() { thread::spawn(|| { for i in 1..10 { println!(\u0026#34;hi number {} from the spawned thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5 { println!(\u0026#34;hi number {} from the main thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } } 程序会输出\nhi number 1 from the main thread! hi number 1 from the spawned thread! hi number 2 from the main thread! hi number 2 from the spawned thread!","title":"Rust并发"},{"content":"使用Box\u0026lt;T\u0026gt;指向堆上的数据 使用box在堆上储存一个i32\nb是一个指向被分配在堆上的值5的Box\nfn main() { let b = Box::new(5); println!(\u0026#34;b = {}\u0026#34;, b); } 用Box\u0026lt;T\u0026gt;可以实现类似链表的结构\n#[derive(Debug)] enum List { Cons(i32, Box\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; fn main() { let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); println!(\u0026#34;{:?}\u0026#34;, list) }  通过Deref trait将智能指针当作常规引用处理 通过解引用运算符追踪指针的值 常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。\nfn main() { let x = 5; let y = \u0026amp;x; assert_eq!(5, x); assert_eq!(5, *y); } 如果使用下面的代码则会出错\nfn main() { let x = 5; let y = \u0026amp;x; assert_eq!(5, x); assert_eq!(5, y); } 不允许比较数字的引用与数字，因为它们是不同的类型。必须使用解引用运算符追踪引用所指向的值。\n像引用一样使用Box\u0026lt;T\u0026gt; fn main() { let x = 5; let y = Box::new(x); assert_eq!(5, x); assert_eq!(5, *y); } 自定义智能指针 #[derive(Debug)] struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } fn main() { let a = 5; let b = MyBox::new(a); assert_eq!(5, a); assert_eq!(5, *b); } 这里我们定义了一个智能指针MyBox，并尝试使用Box的解引用方法，但是会出错，因为rust不知道怎么解引用MyBox，需要实现deref方法才行\nuse std::ops::Deref; #[derive(Debug)] struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target { \u0026amp;self.0 } } fn main() { let a = 5; let b = MyBox::new(a); assert_eq!(5, a); assert_eq!(5, *b); } 函数和方法的隐式解引用强制多态 解引用强制多态的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 \u0026amp; 和 * 的引用和解引用。\n如下面代码\nfn main() { let m = Box::new(String::from(\u0026#34;murphy\u0026#34;)); hello(\u0026amp;(*m)); } fn hello(name: \u0026amp;str) { println!(\u0026#34;hello, {}\u0026#34;, name); } 可以直接写成\nfn main() { let m = Box::new(String::from(\u0026#34;murphy\u0026#34;)); hello(\u0026amp;m); } fn hello(name: \u0026amp;str) { println!(\u0026#34;hello, {}\u0026#34;, name); }  使用Drop Trait运行清理代码  Rc\u0026lt;T\u0026gt;引用计数智能指针 大部分情况下所有权是非常明确的：可以准确地知道哪个变量拥有某个值。然而，有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的节点，而这个节点从概念上讲为所有指向它的边所拥有。节点直到没有任何边指向它之前都不应该被清理。\n使用Rc\u0026lt;T\u0026gt;共享数据 如下代码是无法运行的，因为a的所有权已经移动给b了\nfn main() { let a = Box::new(String::from(\u0026#34;hello, world\u0026#34;)); let b = Box::new(a); let c = Box::new(a); println!(\u0026#34;{},{}\u0026#34;, b, c) } 如果要有多个所有者就要使用引用计数Rc\u0026lt;T\u0026gt;\nuse std::rc::Rc; fn main() { let a = Rc::new(String::from(\u0026#34;hello, world\u0026#34;)); let b = Rc::clone(\u0026amp;a); let c = Rc::clone(\u0026amp;a); println!(\u0026#34;b:{},c:{}\u0026#34;, b, c) }  RefCell\u0026lt;T\u0026gt;和内部可变性模式 ","permalink":"https://murphywzhu.github.io/blog/posts/rust-10/","summary":"使用Box\u0026lt;T\u0026gt;指向堆上的数据 使用box在堆上储存一个i32\nb是一个指向被分配在堆上的值5的Box\nfn main() { let b = Box::new(5); println!(\u0026#34;b = {}\u0026#34;, b); } 用Box\u0026lt;T\u0026gt;可以实现类似链表的结构\n#[derive(Debug)] enum List { Cons(i32, Box\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; fn main() { let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); println!(\u0026#34;{:?}\u0026#34;, list) }  通过Deref trait将智能指针当作常规引用处理 通过解引用运算符追踪指针的值 常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。\nfn main() { let x = 5; let y = \u0026amp;x; assert_eq!(5, x); assert_eq!(5, *y); } 如果使用下面的代码则会出错\nfn main() { let x = 5; let y = \u0026amp;x; assert_eq!","title":"Rust智能指针"},{"content":"编写测试 先创建一个新的库项目\ncargo new adder --lib 会自动生成src/lib.rs\n#[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } } ","permalink":"https://murphywzhu.github.io/blog/posts/rust-08/","summary":"编写测试 先创建一个新的库项目\ncargo new adder --lib 会自动生成src/lib.rs\n#[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } } ","title":"Rust测试"},{"content":"泛型数据类型 在函数定义中使用泛型\n下面代码有两个函数，找出最大的数字和字母的\nfn largest_i32(list: \u0026amp;[i32]) -\u0026gt; i32 { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn largest_char(list: \u0026amp;[char]) -\u0026gt; char { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest_i32(\u0026amp;number_list); println!(\u0026#34;The largest number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest_char(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } 这两个函数实现的功能都是一样的\n所以可以使用泛型来把他们整合到一起\nfn largest\u0026lt;T\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest(\u0026amp;number_list); println!(\u0026#34;The largest number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } 结构体中的泛型\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } fn main() { let integer = Point { x: 5, y: 10 }; let float = Point { x: 1.0, y: 4.0 }; } 下面代码是错误的，类型都是T说明xy类型一样\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } fn main() { let wont_work = Point { x: 5, y: 4.0 }; } struct Point\u0026lt;T, U\u0026gt; { x: T, y: U, } fn main() { let both_integer = Point { x: 5, y: 10 }; let both_float = Point { x: 1.0, y: 4.0 }; let integer_and_float = Point { x: 5, y: 4.0 }; } 枚举定义中的泛型\nenum Option\u0026lt;T\u0026gt; { Some(T), None, } enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } 方法定义中的泛型\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } fn main() { let p = Point { x: 5, y: 10 }; println!(\u0026#34;p.x = {}\u0026#34;, p.x()); } struct Point\u0026lt;T, U\u0026gt; { x: T, y: U, } impl\u0026lt;T, U\u0026gt; Point\u0026lt;T, U\u0026gt; { fn mixup\u0026lt;V, W\u0026gt;(self, other: Point\u0026lt;V, W\u0026gt;) -\u0026gt; Point\u0026lt;T, W\u0026gt; { Point { x: self.x, y: other.y, } } } fn main() { let p1 = Point { x: 5, y: 10.4 }; let p2 = Point { x: \u0026#34;Hello\u0026#34;, y: \u0026#39;c\u0026#39;}; let p3 = p1.mixup(p2); println!(\u0026#34;p3.x = {}, p3.y = {}\u0026#34;, p3.x, p3.y); } 还可以只对一种类型提供方法\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn get_x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } impl Point\u0026lt;String\u0026gt; { fn x_add(\u0026amp;mut self, str: \u0026amp;String) { self.x = format!(\u0026#34;{}{}\u0026#34;, self.x, str) } } fn main() { let a1 = Point { x: 5, y: 10 }; println!(\u0026#34;{}\u0026#34;, a1.get_x()); let mut a2 = Point { x: String::from(\u0026#34;Hello\u0026#34;), y: String::from(\u0026#34;world\u0026#34;) }; let str = String::from(\u0026#34;world\u0026#34;); a2.x_add(\u0026amp;str); println!(\u0026#34;{}\u0026#34;, a2.get_x()); } trait:定义共享的行为 trait类似于其他语言的接口功能\n定义trait\n","permalink":"https://murphywzhu.github.io/blog/posts/rust-07/","summary":"泛型数据类型 在函数定义中使用泛型\n下面代码有两个函数，找出最大的数字和字母的\nfn largest_i32(list: \u0026amp;[i32]) -\u0026gt; i32 { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn largest_char(list: \u0026amp;[char]) -\u0026gt; char { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest_i32(\u0026amp;number_list); println!","title":"Rust泛型、trait与生命周期"},{"content":"panic!与不可恢复的错误 调用panic!\nfn main() { panic!(\u0026#34;crash and burn\u0026#34;); } Result与可恢复的错误 use std::fs::File; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; { panic!(\u0026#34;Problem opening the file: {:?}\u0026#34;, error) }, }; } 匹配不同的错误\nuse std::fs::File; use std::io::ErrorKind; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; match error.kind() { ErrorKind::NotFound =\u0026gt; match File::create(\u0026#34;hello.txt\u0026#34;) { Ok(fc) =\u0026gt; fc, Err(e) =\u0026gt; panic!(\u0026#34;Problem creating the file: {:?}\u0026#34;, e), }, other_error =\u0026gt; panic!(\u0026#34;Problem opening the file: {:?}\u0026#34;, other_error), }, }; } 失败时panic的简写\nuse std::fs::File; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;).unwrap(); } use std::fs::File; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;).expect(\u0026#34;Failed to open hello.txt\u0026#34;); } 传播错误\nuse std::io; use std::io::Read; use std::fs::File; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let f = File::open(\u0026#34;hello.txt\u0026#34;); let mut f = match f { Ok(file) =\u0026gt; file, Err(e) =\u0026gt; return Err(e), }; let mut s = String::new(); match f.read_to_string(\u0026amp;mut s) { Ok(_) =\u0026gt; Ok(s), Err(e) =\u0026gt; Err(e), } } 传播错误的简写\nuse std::io; use std::io::Read; use std::fs::File; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let mut f = File::open(\u0026#34;hello.txt\u0026#34;)?; let mut s = String::new(); f.read_to_string(\u0026amp;mut s)?; Ok(s) } ","permalink":"https://murphywzhu.github.io/blog/posts/rust-06/","summary":"panic!与不可恢复的错误 调用panic!\nfn main() { panic!(\u0026#34;crash and burn\u0026#34;); } Result与可恢复的错误 use std::fs::File; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; { panic!(\u0026#34;Problem opening the file: {:?}\u0026#34;, error) }, }; } 匹配不同的错误\nuse std::fs::File; use std::io::ErrorKind; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; match error.kind() { ErrorKind::NotFound =\u0026gt; match File::create(\u0026#34;hello.txt\u0026#34;) { Ok(fc) =\u0026gt; fc, Err(e) =\u0026gt; panic!","title":"Rust错误处理"},{"content":"vector vector在内存中是连续的，只能存储相同类型的值\n新建vector\nlet v: Vec\u0026lt;i32\u0026gt; = Vec::new(); 或者使用rust提供的vec!宏来新建一个vector\nlet v = vec![1, 2, 3]; 更新vector\nlet mut v = Vec::new();//需要可变才能改变 v.push(5); 读取vector的元素\nlet v = vec![1, 2, 3, 4, 5]; let third: \u0026amp;i32 = \u0026amp;v[2]; println!(\u0026#34;The third element is {}\u0026#34;, third); match v.get(2) { Some(third) =\u0026gt; println!(\u0026#34;The third element is {}\u0026#34;, third), None =\u0026gt; println!(\u0026#34;There is no third element.\u0026#34;), } 下面代码会报错\nlet mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6);//加入一个元素会使v重新分配一块连续的地址，所以原来的引用就无效了，rust不允许无效引用 println!(\u0026#34;The first element is: {}\u0026#34;, first); 遍历vector\nlet v = vec![1, 2, 3, 4, 5]; for i in \u0026amp;v { println!(\u0026#34;{}\u0026#34;, i); } 使用枚举来存储多种类型\nvector只能存储一种类型，而枚举算一种类型，可以用枚举来存储多种类型\n#![allow(unused)] fn main() { enum SpreadsheetCell { Int(i32), Float(f64), Text(String), } let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\u0026#34;blue\u0026#34;)), SpreadsheetCell::Float(10.12), ]; } 字符串 新建字符串\nlet mut s = String::new();//新建空字符串 let s = \u0026#34;initial contents\u0026#34;.to_string();//用to_string新建字符串 let s = String::from(\u0026#34;initial contents\u0026#34;);//用from新建字符串 更新字符串\nlet mut s = String::from(\u0026#34;hello\u0026#34;); s.push_str(\u0026#34;world\u0026#34;);//将字符串添加到string s.push(\u0026#39;!\u0026#39;);//将字符添加到string 使用+或format!拼接字符串\nlet s1 = String::from(\u0026#34;Hello,\u0026#34;); let s2 = String::from(\u0026#34;world!\u0026#34;); let s3 = s1 + \u0026amp;s2;//s1 被移动了，不能继续使用 let s1 = String::from(\u0026#34;tic\u0026#34;); let s2 = String::from(\u0026#34;tac\u0026#34;); let s3 = String::from(\u0026#34;toe\u0026#34;); let s = format!(\u0026#34;{}-{}-{}\u0026#34;, s1, s2, s3);//会获取任何参数的所有权 遍历字符串\nfor c in \u0026#34;你好，世界\u0026#34;.chars() { println!(\u0026#34;{}\u0026#34;, c); } 哈希map键值对 新建一个哈希map\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); 哈希map所有的键必须是相同类型，所有的值也必须是相同类型\n也可以使用下面的方法构建一个哈希map\nuse std::collections::HashMap; let teams = vec![String::from(\u0026#34;Blue\u0026#34;), String::from(\u0026#34;Yellow\u0026#34;)]; let initial_scores = vec![10, 50]; let scores: HashMap\u0026lt;_, _\u0026gt; = teams.iter().zip(initial_scores.iter()).collect(); 访问哈希map\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); let team_name = String::from(\u0026#34;Blue\u0026#34;); let score = scores.get(\u0026amp;team_name); 遍历哈希map\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); for (key, value) in \u0026amp;scores { println!(\u0026#34;{}: {}\u0026#34;, key, value); } 更新哈希map\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 25); println!(\u0026#34;{:?}\u0026#34;, scores); 在没有值时更新哈希map\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.entry(String::from(\u0026#34;Yellow\u0026#34;)).or_insert(50); scores.entry(String::from(\u0026#34;Blue\u0026#34;)).or_insert(50); println!(\u0026#34;{:?}\u0026#34;, scores); ","permalink":"https://murphywzhu.github.io/blog/posts/rust-05/","summary":"vector vector在内存中是连续的，只能存储相同类型的值\n新建vector\nlet v: Vec\u0026lt;i32\u0026gt; = Vec::new(); 或者使用rust提供的vec!宏来新建一个vector\nlet v = vec![1, 2, 3]; 更新vector\nlet mut v = Vec::new();//需要可变才能改变 v.push(5); 读取vector的元素\nlet v = vec![1, 2, 3, 4, 5]; let third: \u0026amp;i32 = \u0026amp;v[2]; println!(\u0026#34;The third element is {}\u0026#34;, third); match v.get(2) { Some(third) =\u0026gt; println!(\u0026#34;The third element is {}\u0026#34;, third), None =\u0026gt; println!(\u0026#34;There is no third element.\u0026#34;), } 下面代码会报错\nlet mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.","title":"Rust集合"},{"content":"枚举 定义枚举\nenum IpAddrKind { V4, V6, } 枚举值\nlet four = IpAddrKind::V4; let six = IpAddrKind::V6; 他们的类型都是IpAddrKind\n如函数：\nfn rout(ip_type: IpAddrKind) { } 可以向下面一样调用\nroute(IpAddrKind::V4); route(IpAddrKind::V6); match控制流运算符 enum Coin { Penny, Nickel, Dime, Quarter, } let a = Coin::Penny; let b = match a { Coin::Penny =\u0026gt; 1, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter =\u0026gt; 25, }; println!(\u0026#34;{}\u0026#34;, b); let c = match a { Coin::Penny =\u0026gt; { println!(\u0026#34;Lucky penny!\u0026#34;); 1 }, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter =\u0026gt; 25, } 绑定值的模式\n可以用来获取枚举绑定的值\nenum Ip { V4(u8, u8, u8, u8), V6(String), } fn print_ip(ip: \u0026amp;Ip) { match ip { Ip::V4(a, b, c, d) =\u0026gt; println!(\u0026#34;{}.{}.{}.{}\u0026#34;, a, b, c, d), Ip::V6(a) =\u0026gt; println!(\u0026#34;{}\u0026#34;, a), } } fn main() { let ip4 = Ip::V4(127, 0, 0, 1); let ip6 = Ip::V6(String::from(\u0026#34;::1\u0026#34;)); print_ip(\u0026amp;ip4); print_ip(\u0026amp;ip6); } 通配符\nrust的match必须列出所有可能，有时候只需要几个匹配，其他的可以用通配符_来匹配\nlet some_u8_value = 0u8; match some_u8_value { 1 =\u0026gt; println!(\u0026#34;one\u0026#34;), 3 =\u0026gt; println!(\u0026#34;three\u0026#34;), 5 =\u0026gt; println!(\u0026#34;five\u0026#34;), 7 =\u0026gt; println!(\u0026#34;seven\u0026#34;), _ =\u0026gt; (), } ","permalink":"https://murphywzhu.github.io/blog/posts/rust-04/","summary":"枚举 定义枚举\nenum IpAddrKind { V4, V6, } 枚举值\nlet four = IpAddrKind::V4; let six = IpAddrKind::V6; 他们的类型都是IpAddrKind\n如函数：\nfn rout(ip_type: IpAddrKind) { } 可以向下面一样调用\nroute(IpAddrKind::V4); route(IpAddrKind::V6); match控制流运算符 enum Coin { Penny, Nickel, Dime, Quarter, } let a = Coin::Penny; let b = match a { Coin::Penny =\u0026gt; 1, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter =\u0026gt; 25, }; println!(\u0026#34;{}\u0026#34;, b); let c = match a { Coin::Penny =\u0026gt; { println!","title":"Rust枚举和模式匹配"},{"content":"Podman podman是一个无守护进程的容器引擎，它还可以实现无根运行容器，现在最新版本的红帽系Linux都默认使用podman。\n在Archlinux上安装podman 安装podman\nsudo pacman -S podman crun 配置无根运行\nsudo touch /etc/subuid /etc/subgid sudo usermod --add-subuids 100000-165536 --add-subgids 100000-165536 username #将username替换为用户名 查看podman信息\npodman info 配置podman镜像仓库 新建registries.conf配置文件\nmkdir -p $HOME/.config/containers vim $HOME/.config/containers/registries.conf 将以下内容写入registries.conf\nunqualified-search-registries = [\u0026#34;docker.io\u0026#34;] [[registry]] prefix = \u0026#34;docker.io\u0026#34; location = \u0026#34;docker.mirrors.sjtug.sjtu.edu.cn\u0026#34; 查看是否成功\npodman info | grep Location 输出：Location: docker.mirrors.sjtug.sjtu.edu.cn ","permalink":"https://murphywzhu.github.io/blog/posts/podman-00/","summary":"Podman podman是一个无守护进程的容器引擎，它还可以实现无根运行容器，现在最新版本的红帽系Linux都默认使用podman。\n在Archlinux上安装podman 安装podman\nsudo pacman -S podman crun 配置无根运行\nsudo touch /etc/subuid /etc/subgid sudo usermod --add-subuids 100000-165536 --add-subgids 100000-165536 username #将username替换为用户名 查看podman信息\npodman info 配置podman镜像仓库 新建registries.conf配置文件\nmkdir -p $HOME/.config/containers vim $HOME/.config/containers/registries.conf 将以下内容写入registries.conf\nunqualified-search-registries = [\u0026#34;docker.io\u0026#34;] [[registry]] prefix = \u0026#34;docker.io\u0026#34; location = \u0026#34;docker.mirrors.sjtug.sjtu.edu.cn\u0026#34; 查看是否成功\npodman info | grep Location 输出：Location: docker.mirrors.sjtug.sjtu.edu.cn ","title":"在Archlinux上安装Podman"},{"content":"结构体 定义结构体\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } 创建结构体实例\nlet mut user1 = User { email: String::from(\u0026#34;Murphy.W.Zhu@aliyun.com\u0026#34;), username: String::from(\u0026#34;Murphy.W.Zhu\u0026#34;), active: true, sign_in_count: 1, }; 改变实例属性\nuser1.email = String::from(\u0026#34;Murphy.W.Zhu@aliyun.com\u0026#34;); 返回结构体\nfn build_user(email: String, username: String) -\u0026gt; User { User { email: email, username: username, active: true, sign_in_count: 1, } } 变量与字段同名是的字段初始化简写语法\nfn build_user(email: String, username: String) -\u0026gt; User { User { email, username, active: true, sign_in_count: 1, } } 使用结构体更新语法从其他实例创建实例\nlet user2 = User { email: String::from(\u0026#34;Murphy.W.Zhu@aliyun.com\u0026#34;), username: String::from(\u0026#34;Murphy.W.Zhu\u0026#34;), active: user1.active, sign_in_count: user1.sign_in_count, }; 相同的部分可以简写\nlet user2 = User { email: String::from(\u0026#34;Murphy.W.Zhu1@aliyun.com\u0026#34;), username: String::from(\u0026#34;Murphy.W.Zhu1\u0026#34;), ..user1 }; 元组结构体 元组结构体相当于没有字段名的结构体\nstruct Color(i32, i32, i32); let mut black = Color(0, 1, 0); black.1 = 0;//可以使用.的方式访问 println!(\u0026#34;{},{},{}\u0026#34;, black.0,black.1,black.2); 在函数中使用结构体 结构体也是有所有权的，所以要借用\nstruct Rectangle { width: u32, height: u32, } fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!( \u0026#34;The area of the rectangle is {} square pixels.\u0026#34;, area(\u0026amp;rect1) ); } fn area(rectangle: \u0026amp;Rectangle) -\u0026gt; u32 { rectangle.width * rectangle.height } 结构体方法 方法与函数类似，像其他面向对象的语言中一样，方法的第一个参数是self\n定义方法\nstruct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!( \u0026#34;The area of the rectangle is {} square pixels.\u0026#34;, rect1.area() ); } 带有更多参数的方法\nstruct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } fn can_hold(\u0026amp;self, other: \u0026amp;Rectangle) -\u0026gt; bool { self.width \u0026gt; other.width \u0026amp;\u0026amp; self.height \u0026gt; other.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50 }; let rect2 = Rectangle { width: 10, height: 40 }; let rect3 = Rectangle { width: 60, height: 45 }; println!(\u0026#34;Can rect1 hold rect2? {}\u0026#34;, rect1.can_hold(\u0026amp;rect2)); println!(\u0026#34;Can rect1 hold rect3? {}\u0026#34;, rect1.can_hold(\u0026amp;rect3)); } 关联函数\n参数不包含self，关联函数经常被用作返回一个结构体新实例的构造函数。\nimpl Rectangle { fn square(size: u32) -\u0026gt; Rectangle { Rectangle { width: size, height: size } } } let sq = Rectangle::square(3); ","permalink":"https://murphywzhu.github.io/blog/posts/rust-03/","summary":"结构体 定义结构体\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } 创建结构体实例\nlet mut user1 = User { email: String::from(\u0026#34;Murphy.W.Zhu@aliyun.com\u0026#34;), username: String::from(\u0026#34;Murphy.W.Zhu\u0026#34;), active: true, sign_in_count: 1, }; 改变实例属性\nuser1.email = String::from(\u0026#34;Murphy.W.Zhu@aliyun.com\u0026#34;); 返回结构体\nfn build_user(email: String, username: String) -\u0026gt; User { User { email: email, username: username, active: true, sign_in_count: 1, } } 变量与字段同名是的字段初始化简写语法\nfn build_user(email: String, username: String) -\u0026gt; User { User { email, username, active: true, sign_in_count: 1, } } 使用结构体更新语法从其他实例创建实例","title":"Rust结构体"},{"content":"我在ArchLinux上用Typora的时候发现代码块字体不是等宽字体，就非常的难受\n在网上搜索之后，找到了解决办法\n新建这个文件~/.config/Typora/themes/base.user.css\n写入以下内容，字体可以替换为喜欢的字体\n~/.config/Typora/themes/base.user.css .CodeMirror-wrap .CodeMirror-code pre { font-family: Fira Code; } .md-fences,code,tt { font-family: Fira Code; } 保存重启就好了\n","permalink":"https://murphywzhu.github.io/blog/posts/typora-00/","summary":"我在ArchLinux上用Typora的时候发现代码块字体不是等宽字体，就非常的难受\n在网上搜索之后，找到了解决办法\n新建这个文件~/.config/Typora/themes/base.user.css\n写入以下内容，字体可以替换为喜欢的字体\n~/.config/Typora/themes/base.user.css .CodeMirror-wrap .CodeMirror-code pre { font-family: Fira Code; } .md-fences,code,tt { font-family: Fira Code; } 保存重启就好了","title":"Typora设置等宽字体"},{"content":" Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.\n Hugo是一个静态网页框架，可以快速生成网页，并且拥有许多的主题\n安装Hugo 在archlinux中\nsudo pacman -S hugo 使用源码安装\n需要有git和go(\u0026gt;=1.11)\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended % hugo version hugo v0.82.0+extended linux/amd64 BuildDate=unknown 创建网站 先在github上新建一个项目\n然后新建一个hugo网站项目\nhugo new site blog -f yml 初始化git，并设置默认分支名为main\ngit init git branch -m main 设置主题，这里设置PaperMod主题\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 git submodule update --init --recursive 然后生成静态网页\nhugo -d docs 上传到github\ngit add * git commit -m \u0026quot;first commit\u0026quot; git remote add origin git@github.com:MurphyWZhu/blog.git git push -u origin main 设置github\n配置网站\n下面是一些我的配置，可以根据需要修改\nbaseURL: https://murphywzhu.github.io/blog/ languageCode: zh-cn defaultContentLanguage: zh-cn title: 锦酱的博客 theme: \u0026#34;PaperMod\u0026#34; languages: zh-cn: languageName: \u0026#34;简体中文\u0026#34; weight: 1 menu: main: - name: Search url: search/ weight: 10 - name: Tags url: tags/ weight: 10 params: profileMode: enabled: true title: \u0026#34;锦酱\u0026#34; # optional default will be site title subtitle: \u0026#34;锦酱!又出Bug啦!\u0026#34; imageUrl: \u0026#34;https://mublog.oss-cn-beijing.aliyuncs.com/mutx.jpeg\u0026#34; # optional imageTitle: \u0026#34;图片被吃掉了哎!\u0026#34; # optional imageWidth: 120 # custom size imageHeight: 120 # custom size buttons: - name: 文章 url: \u0026#34;posts/\u0026#34; - name: Github url: \u0026#34;https://github.com/murphywzhu\u0026#34; outputs: home: - HTML - RSS - JSON # is necessary 然后生成并push到github上\nhugo -d docs git add * git commit -m \u0026quot;updates $(date)\u0026quot; git push -u origin main 也可以将这些步骤写成脚本\n#! /bin/bash  hugo -d docs git add * git commit -m \u0026#34;updates $(date)\u0026#34; git push -u origin main 接下来就应该可以访问了\n","permalink":"https://murphywzhu.github.io/blog/posts/hugo-00/","summary":"Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.\n Hugo是一个静态网页框架，可以快速生成网页，并且拥有许多的主题\n安装Hugo 在archlinux中\nsudo pacman -S hugo 使用源码安装\n需要有git和go(\u0026gt;=1.11)\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended % hugo version hugo v0.82.0+extended linux/amd64 BuildDate=unknown 创建网站 先在github上新建一个项目\n然后新建一个hugo网站项目\nhugo new site blog -f yml 初始化git，并设置默认分支名为main\ngit init git branch -m main 设置主题，这里设置PaperMod主题","title":"使用Hugo在github上搭建博客"},{"content":"所有权 所有权是rust的核心之一\n它有如下规则\n1、Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。 2、值在任一时刻有且只有一个所有者。 3、当所有者（变量）离开作用域，这个值将被丢弃。 变量作用域 #![allow(unused)] fn main() { { // s 在这里无效, 它尚未声明  let s = \u0026#34;hello\u0026#34;; // 从此处起，s 是有效的  // 使用 s } // 此作用域已结束，s 不再有效 } String类型 之前的类型都是栈上的，现在需要一个堆上的类型，String就是我们需要的类型\nlet s = String::from(\u0026#34;hello\u0026#34;); 对于栈上的数据rust直接复制了\nlet x = 5; let y = x; 对于堆上的数据，rust将原来的内存给了之后的，而原来的就无效了\n如下代码会错误，因为s1无效了，所以发生了无效引用\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); 如果要复制String的数据可以使用clone\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;s1 = {}, s2 = {}\u0026#34;, s1, s2); 所有权与函数 以下程序会报错\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); print_str(a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : String) { println!(\u0026#34;{}\u0026#34;, str); } 说a已经被移动了\nerror[E0382]: borrow of moved value: `a` --\u0026gt; src/main.rs:4:20 | 2 | let a = String::from(\u0026#34;Hello\u0026#34;); | - move occurs because `a` has type `String`, which does not implement the `Copy` trait 3 | print_str(a); | - value moved here 4 | println!(\u0026#34;{}\u0026#34;, a); | ^ value borrowed here after move 这是因为啊的所有权被移动到了print_str函数里，函数结束所有权就消失了\n那应该怎么办呢，不用担心，函数返回值的时候也会返回所有权，我们只需要将原来的参数返回就行\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); let b = print_str(a); println!(\u0026#34;{}\u0026#34;, b); } fn print_str(str : String) -\u0026gt; String{ println!(\u0026#34;{}\u0026#34;, str); str } 也可以像下面一样，将要返回的东西和原来的参数一起返回，不过这样着实是有些麻烦，不过我们接下来的东西可以解决\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let (s2, len) = calculate_length(s1); println!(\u0026#34;The length of \u0026#39;{}\u0026#39; is {}.\u0026#34;, s2, len); } fn calculate_length(s: String) -\u0026gt; (String, usize) { let length = s.len(); // len() 返回字符串的长度  (s, length) } 借用 像下面这样在类型前面加个\u0026amp;就是借用了，借用是不能改变值的。\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); print_str(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : \u0026amp;String){ println!(\u0026#34;{}\u0026#34;, str); } 以下程序就会报错\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); print_str(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : \u0026amp;String){ str.push_str(\u0026#34;,World!\u0026#34;); } error[E0596]: cannot borrow `*str` as mutable, as it is behind a `\u0026amp;` reference --\u0026gt; src/main.rs:8:5 | 7 | fn print_str(str : \u0026amp;String){ | ------- help: consider changing this to be a mutable reference: `\u0026amp;mut String` 8 | str.push_str(\u0026#34;,World!\u0026#34;); | ^^^ `str` is a `\u0026amp;` reference, so the data it refers to cannot be borrowed as mutable 没错，也可以像可变变量一样加个mut变成可变引用\n以下程序会输出Hello,World!\n要可以引用的话，变量本身也需要可变\nfn main() { let mut a = String::from(\u0026#34;Hello\u0026#34;); print_str(\u0026amp;mut a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : \u0026amp;mut String){ str.push_str(\u0026#34;,World!\u0026#34;); } 在特定作用域中的特定数据只能有一个可变引用。这些代码会失败：\nlet mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026#34;{}, {}\u0026#34;, r1, r2); error[E0499]: cannot borrow `s` as mutable more than once at a time --\u0026gt; src/main.rs:5:14 | 4 | let r1 = \u0026amp;mut s; | ------ first mutable borrow occurs here 5 | let r2 = \u0026amp;mut s; | ^^^^^^ second mutable borrow occurs here 6 | 7 | println!(\u0026#34;{}, {}\u0026#34;, r1, r2); | -- first borrow later used here 可以理解为一个对象只能同时存在一个可用的引用\n以下代码就可以使用\nlet mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026#34;{}\u0026#34;, r2); 因为r1在r2之后不再使用\n悬垂引用 Rust里的悬垂引用相当于其他语言里的悬垂指针，内存释放了，指针还在的意思\n以下程序会出现悬垂引用\nfn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { let s = String::from(\u0026#34;hello\u0026#34;); \u0026amp;s } error[E0106]: missing lifetime specifier --\u0026gt; src/main.rs:5:16 | 5 | fn dangle() -\u0026gt; \u0026amp;String { | ^ expected named lifetime parameter | = help: this function\u0026#39;s return type contains a borrowed value, but there is no value for it to be borrowed from help: consider using the `\u0026#39;static` lifetime | 5 | fn dangle() -\u0026gt; \u0026amp;\u0026#39;static String { | ^^^^^^^^ 因为s的作用域在{}之间，出了作用域就被释放了，这样返回的引用就变成了悬垂引用\n解决办法就是直接返回String\nfn no_dangle() -\u0026gt; String { let s = String::from(\u0026#34;hello\u0026#34;); s } ","permalink":"https://murphywzhu.github.io/blog/posts/rust-02/","summary":"所有权 所有权是rust的核心之一\n它有如下规则\n1、Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。 2、值在任一时刻有且只有一个所有者。 3、当所有者（变量）离开作用域，这个值将被丢弃。 变量作用域 #![allow(unused)] fn main() { { // s 在这里无效, 它尚未声明  let s = \u0026#34;hello\u0026#34;; // 从此处起，s 是有效的  // 使用 s } // 此作用域已结束，s 不再有效 } String类型 之前的类型都是栈上的，现在需要一个堆上的类型，String就是我们需要的类型\nlet s = String::from(\u0026#34;hello\u0026#34;); 对于栈上的数据rust直接复制了\nlet x = 5; let y = x; 对于堆上的数据，rust将原来的内存给了之后的，而原来的就无效了\n如下代码会错误，因为s1无效了，所以发生了无效引用\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); 如果要复制String的数据可以使用clone\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.","title":"Rust所有权"},{"content":"不变变量 以下程序理所当然的输出5\nfn main() { let a = 5; println!(\u0026#34;{}\u0026#34;, a); } 而当你尝试改变a的值时\nfn main() { let a = 5; a = 6; println!(\u0026#34;{}\u0026#34;, a); } 则会出现错误\nerror[E0384]: cannot assign twice to immutable variable `a` --\u0026gt; src/main.rs:3:5 | 2 | let a = 5; | - | | | first assignment to `a` | help: make this binding mutable: `mut a` 3 | a = 6; | ^^^^^ cannot assign twice to immutable variable rust会很人性化的提示你哪里错了，还会给出建议\n这就是因为rust变量默认是不可改变的，要改变的话需要声明他是可变的，就像他提示的那样\nfn main() { let mut a = 5; a = 6; println!(\u0026#34;{}\u0026#34;, a); }  常量 rust变量默认不可变，那好像和常量一样，常量不光默认不能变，它总是不能变。常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。\nconst MAX_POINTS: u32 = 100_000;  数据类型 声明 let x: i64 = 10; let x = 5.5; char类型 rust的char为四个字节，代表一个unicode标量值，所以可以使用emoji、中文字符等等\nlet c = \u0026#39;z\u0026#39;; let z = \u0026#39;ℤ\u0026#39;; let heart_eyed_cat = \u0026#39;😻\u0026#39;; 元组(tup) let tup: (i32, f64, u8) = (500, 6.4, 1); let tup = (500, 6.4, 1); println!(\u0026#34;{}\u0026#34;, tup.0); 元组默认也是不可变的，也需要加mut声明可变才可改变\nlet mut tup = (50, 6.1, 5); tup.0 = 55; 数组(array) 数组是固定长度的，一旦声明，它们的长度不能增长或缩小。\nlet a = [1, 2, 3, 4, 5]; let b: [i32; 5] = [1, 2, 3, 4, 5]; let c = [3; 5];//[3,3,3,3,3] println!(\u0026#34;{}\u0026#34;, a[0]); 数组同样也是不可变的啦，也要加mut才可改变\nlet mut list = [5, 5, 5, 5];  函数 函数是面向过程的语言里非常重要的一个东西\n在rust里的函数的定义如下\nfn func_name(x: i32) -\u0026gt; i32 { x*2 } fn func_name(x: i32) -\u0026gt; i32 { return x*2 } rust函数的最后一条表达式的值当作返回值，也可以使用return返回\nrust里只有表达式才有值，函数调用也是表达式\n 控制流 if表达式 if语句也是表达式所以也有值\n一下程序会输出20\nfn main() { let a = 10; let b = if a \u0026gt; 10 { a } else { a*2 }; println!(\u0026#34;{}\u0026#34;, b); } rust的if语句中的条件只能是值为bool型的表达式\nloop循环 fn main() { loop { println!(\u0026#34;again!\u0026#34;); } } 可以用break退出循环，loop表达式的值，即是break后面的表达式的值\n下面程序会输出20\nfn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\u0026#34;The result is {}\u0026#34;, result); } while条件循环 fn main() { let mut number = 3; while number != 0 { println!(\u0026#34;{}!\u0026#34;, number); number = number - 1; } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } for循环 fn main() { let a = [10, 20, 30, 40, 50]; for element in a.iter() { println!(\u0026#34;the value is: {}\u0026#34;, element); } } fn main() { for number in (1..4).rev() { println!(\u0026#34;{}!\u0026#34;, number); } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } ","permalink":"https://murphywzhu.github.io/blog/posts/rust-01/","summary":"不变变量 以下程序理所当然的输出5\nfn main() { let a = 5; println!(\u0026#34;{}\u0026#34;, a); } 而当你尝试改变a的值时\nfn main() { let a = 5; a = 6; println!(\u0026#34;{}\u0026#34;, a); } 则会出现错误\nerror[E0384]: cannot assign twice to immutable variable `a` --\u0026gt; src/main.rs:3:5 | 2 | let a = 5; | - | | | first assignment to `a` | help: make this binding mutable: `mut a` 3 | a = 6; | ^^^^^ cannot assign twice to immutable variable rust会很人性化的提示你哪里错了，还会给出建议","title":"Rust常见编程概念"},{"content":"Rust 据官网说介绍rust是一门高性能，高可靠的编程语言，最主要的特点就是安全可靠，据悉Linux内核都在考虑是否用rust代替C\nRust安装 可以使用官方的rustup来安装rust以及其他工具\nsudo pacman -S rustup 设置rustup的下载源\nexport RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup 安装rust\nrustup install stable rustup component add rust-src Helloworld\nCode % cargo new hello-world Created binary (application) `hello-world` package Code % cd hello-world hello-world[master*] % ls Cargo.toml src hello-world[master*] % cargo run Compiling hello-world v0.1.0 (/home/murphy/Code/hello-world) Finished dev [unoptimized + debuginfo] target(s) in 1.15s Running `target/debug/hello-world` Hello, world! Rust IDE rust还没有官方的IDE，我使用Clion的rust插件来写\n","permalink":"https://murphywzhu.github.io/blog/posts/rust/","summary":"Rust 据官网说介绍rust是一门高性能，高可靠的编程语言，最主要的特点就是安全可靠，据悉Linux内核都在考虑是否用rust代替C\nRust安装 可以使用官方的rustup来安装rust以及其他工具\nsudo pacman -S rustup 设置rustup的下载源\nexport RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup 安装rust\nrustup install stable rustup component add rust-src Helloworld\nCode % cargo new hello-world Created binary (application) `hello-world` package Code % cd hello-world hello-world[master*] % ls Cargo.toml src hello-world[master*] % cargo run Compiling hello-world v0.1.0 (/home/murphy/Code/hello-world) Finished dev [unoptimized + debuginfo] target(s) in 1.15s Running `target/debug/hello-world` Hello, world! Rust IDE rust还没有官方的IDE，我使用Clion的rust插件来写","title":"Rust初试"},{"content":"安装前准备 制作启动盘 下载最新版本的archlinux安装镜像文件\nLinux： dd bs=4M if=镜像路径 of=/dev/USB设备标识符 conv=fsync oflag=direct status=progress Windows： 使用Rufus制作\nMacOS： diskutil unmountDisk /dev/USB设备标识符 #MacOS也许会自动挂载USB设备，先卸载 dd if=镜像路径 of=/dev/USB设备标识符 bs=1m 引导系统 将制作好的USB启动盘插在要安装archlinux的电脑上\n开机的时候按某个按键(不同品牌及机器不一样)，进入选择引导介质的界面，选择USB设备\n即可引导进入archlinux live\n安装前配置 setfont /usr/share/kbd/consolefonts/iso01-12x22.psfu.gz #将字体设置大一点 timedatectl set-ntp true #设置网络时间 磁盘设置 分区 archlinux一般需要分一下几个区\n   分区名称 挂载点 分区类型 建议大小     EFI引导分区 /mnt/boot EFI system partition 512M   根分区 /mnt Linux 磁盘剩下的空间   数据分区[可选] /data Linux    家分区[可选] /home Linux     分区要具体看用途，及你的电脑的磁盘配置\n如果只有一块硬盘，可以只分EFI分区及根分区\n如果有一块固态和一块机械，可以把固态分为EFI分区及根分区，机械分为数据分区或家分区\n我的电脑是一块NVME固态和一块SATA固态，我将NVME分为EFI分区及根分区，将SATA分为家分区\nfdisk /dev/nvme0n1 fdisk /dev/sda 格式化分区 EFI分区：\nmkfs.fat -F32 /dev/nvme0n1p1 根分区：\nmkfs.ext4 /dev/nvme0n1p2 数据分区或家分区：\nmkfs.ext4 /dev/sda1 挂载分区 mount /dev/nvme0n1p2 /mnt mkdir /mnt/boot mkdir /mnt/home mount /dev/nvme0n1p1 /mnt/boot mount /dev/sda1 /mnt/home 修改镜像站 修改文件/etc/pacman.d/mirrorlist\nServer = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 安装基本系统 pacstrap /mnt base base-devel linux-zen linux-firmware vim networkmanager iwd iptables-nft linux-zen是另一个linux内核，对原本的内核参数进行了修改，iwd是intel无线网卡驱动，iptables-nft是使用 nft 接口的iptables\n将磁盘挂载信息写入新系统\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 配置系统 切换到新系统\narch-chroot /mnt 设置时区为中国并载入\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc 设置中文支持，修改/etc/locale.gen，之后使配置生效\n/etc/locale.gen..... en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 zh_HK.UTF-8 UTF-8 ..... locale-gen 设置语言为英文utf8，先设置成英文，中文在字符界面会乱码\n/etc/locale.conf LANG=en_US.UTF-8 配置主机名\n/etc/hostname karch 配置hosts文件\n/etc/hosts # Static table lookup for hostnames. # See hosts(5) for details. 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.1.1\tkarch.localdomain\tkarch 设置root密码\npasswd 安装intel cpu微码（或amd-ucode）\npacman -S intel-ucode 配置grub启动\npacman -S grub efibootmgr grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg 配置dkms和显卡驱动(Nvidia独显+Intel集显)\nsudo pacman -S linux-zen-headers dkms sudo pacman -S nvidia-dkms nvidia-prime sudo pacman -S vulkan-intel intel-media-driver libva-intel-driver 安装kde桌面环境，以及pipewire音频管理，和一些常用的软件\nsudo pacman -S plasma konsole dolphin{,-plugins} pipewire{,-alsa,-pulse,-jack} ark gwenview kdialog spectacle kate 安装中文字体和常用字体并设置默认语言为中文\nsudo pacman -S ttf-sarasa-gothic ttf-fira-{code,mono} /etc/locale.confLANG=en_US.UTF-8 安装libreoffice办公套件\nsudo pacman -S libreoffice-fresh{,-zh-cn} okular latte-dock kfind krename kcalc elisa vlc 配置archlinuxcn源\nsudo pacman -S haveged sudo systemctl start haveged sudo systemctl enable haveged sudo vim /etc/pacman.conf sudo rm -rf /etc/pacman.d/gnupg sudo pacman-key --init sudo pacman-key --populate archlinux sudo pacman -S archlinuxcn-keyring 安装chrome浏览器\npacman -S google-chrome 安装输入法\npacman -S fcitx5-im fcitx5-chinese-addons fcitx5-nord fcitx5-pinyin-zhwiki fcitx5-pinyin-moegirl ~/.pam_environmentGTK_IM_MODULE DEFAULT=fcitx QT_IM_MODULE DEFAULT=fcitx XMODIFIERS DEFAULT=\\@im=fcitx SDL_IM_MODULE DEFAULT=fcitx ","permalink":"https://murphywzhu.github.io/blog/posts/arch-install/","summary":"安装前准备 制作启动盘 下载最新版本的archlinux安装镜像文件\nLinux： dd bs=4M if=镜像路径 of=/dev/USB设备标识符 conv=fsync oflag=direct status=progress Windows： 使用Rufus制作\nMacOS： diskutil unmountDisk /dev/USB设备标识符 #MacOS也许会自动挂载USB设备，先卸载 dd if=镜像路径 of=/dev/USB设备标识符 bs=1m 引导系统 将制作好的USB启动盘插在要安装archlinux的电脑上\n开机的时候按某个按键(不同品牌及机器不一样)，进入选择引导介质的界面，选择USB设备\n即可引导进入archlinux live\n安装前配置 setfont /usr/share/kbd/consolefonts/iso01-12x22.psfu.gz #将字体设置大一点 timedatectl set-ntp true #设置网络时间 磁盘设置 分区 archlinux一般需要分一下几个区\n   分区名称 挂载点 分区类型 建议大小     EFI引导分区 /mnt/boot EFI system partition 512M   根分区 /mnt Linux 磁盘剩下的空间   数据分区[可选] /data Linux    家分区[可选] /home Linux     分区要具体看用途，及你的电脑的磁盘配置","title":"Arch Install"},{"content":"这是第一篇文章\necho \u0026quot;Hello World!\u0026quot; ","permalink":"https://murphywzhu.github.io/blog/posts/hello-world/","summary":"这是第一篇文章\necho \u0026quot;Hello World!\u0026quot; ","title":"Hello World"}]