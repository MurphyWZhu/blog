[{"content":"Podman podman是一个无守护进程的容器引擎，它还可以实现无根运行容器，现在最新版本的红帽系Linux都默认使用podman。\n在Archlinux上安装podman 安装podman\nsudo pacman -S podman crun 配置无根运行\nsudo touch /etc/subuid /etc/subgid sudo usermod --add-subuids 100000-165536 --add-subgids 100000-165536 username #将username替换为用户名 查看podman信息\npodman info 配置podman镜像仓库 新建registries.conf配置文件\nmkdir -p $HOME/.config/containers vim $HOME/.config/containers/registries.conf 将以下内容写入registries.conf\nunqualified-search-registries = [\u0026#34;docker.io\u0026#34;] [[registry]] prefix = \u0026#34;docker.io\u0026#34; location = \u0026#34;docker.mirrors.sjtug.sjtu.edu.cn\u0026#34; 查看是否成功\npodman info | grep Location 输出：Location: docker.mirrors.sjtug.sjtu.edu.cn ","permalink":"https://murphywzhu.github.io/blog/posts/podman-00/","summary":"Podman podman是一个无守护进程的容器引擎，它还可以实现无根运行容器，现在最新版本的红帽系Linux都默认使用podman。\n在Archlinux上安装podman 安装podman\nsudo pacman -S podman crun 配置无根运行\nsudo touch /etc/subuid /etc/subgid sudo usermod --add-subuids 100000-165536 --add-subgids 100000-165536 username #将username替换为用户名 查看podman信息\npodman info 配置podman镜像仓库 新建registries.conf配置文件\nmkdir -p $HOME/.config/containers vim $HOME/.config/containers/registries.conf 将以下内容写入registries.conf\nunqualified-search-registries = [\u0026#34;docker.io\u0026#34;] [[registry]] prefix = \u0026#34;docker.io\u0026#34; location = \u0026#34;docker.mirrors.sjtug.sjtu.edu.cn\u0026#34; 查看是否成功\npodman info | grep Location 输出：Location: docker.mirrors.sjtug.sjtu.edu.cn ","title":"在Archlinux上安装Podman"},{"content":"结构体 定义结构体\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } 创建结构体实例\nlet mut user1 = User { email: String::from(\u0026#34;someone@example.com\u0026#34;), username: String::from(\u0026#34;someusername123\u0026#34;), active: true, sign_in_count: 1, }; 改变实例属性\nuser1.email = String::from(\u0026#34;anotheremail@example.com\u0026#34;); 返回结构体\nfn build_user(email: String, username: String) -\u0026gt; User { User { email: email, username: username, active: true, sign_in_count: 1, } } 变量与字段同名是的字段初始化简写语法\nfn build_user(email: String, username: String) -\u0026gt; User { User { email, username, active: true, sign_in_count: 1, } } 使用结构体更新语法从其他实例创建实例\nlet user2 = User { email: String::from(\u0026#34;another@example.com\u0026#34;), username: String::from(\u0026#34;anotherusername567\u0026#34;), active: user1.active, sign_in_count: user1.sign_in_count, }; let user2 = User { email: String::from(\u0026#34;another@example.com\u0026#34;), username: String::from(\u0026#34;anotherusername567\u0026#34;), ..user1 }; ","permalink":"https://murphywzhu.github.io/blog/posts/rust-03/","summary":"结构体 定义结构体\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } 创建结构体实例\nlet mut user1 = User { email: String::from(\u0026#34;someone@example.com\u0026#34;), username: String::from(\u0026#34;someusername123\u0026#34;), active: true, sign_in_count: 1, }; 改变实例属性\nuser1.email = String::from(\u0026#34;anotheremail@example.com\u0026#34;); 返回结构体\nfn build_user(email: String, username: String) -\u0026gt; User { User { email: email, username: username, active: true, sign_in_count: 1, } } 变量与字段同名是的字段初始化简写语法\nfn build_user(email: String, username: String) -\u0026gt; User { User { email, username, active: true, sign_in_count: 1, } } 使用结构体更新语法从其他实例创建实例","title":"Rust结构体"},{"content":"我在ArchLinux上用Typora的时候发现代码块字体不是等宽字体，就非常的难受\n在网上搜索之后，找到了解决办法\n新建这个文件~/.config/Typora/themes/base.user.css\n写入以下内容，字体可以替换为喜欢的字体\n~/.config/Typora/themes/base.user.css .CodeMirror-wrap .CodeMirror-code pre { font-family: Fira Code; } .md-fences,code,tt { font-family: Fira Code; } 保存重启就好了\n","permalink":"https://murphywzhu.github.io/blog/posts/typora-00/","summary":"我在ArchLinux上用Typora的时候发现代码块字体不是等宽字体，就非常的难受\n在网上搜索之后，找到了解决办法\n新建这个文件~/.config/Typora/themes/base.user.css\n写入以下内容，字体可以替换为喜欢的字体\n~/.config/Typora/themes/base.user.css .CodeMirror-wrap .CodeMirror-code pre { font-family: Fira Code; } .md-fences,code,tt { font-family: Fira Code; } 保存重启就好了","title":"Typora设置等宽字体"},{"content":" Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.\n Hugo是一个静态网页框架，可以快速生成网页，并且拥有许多的主题\n安装Hugo 在archlinux中\nsudo pacman -S hugo 使用源码安装\n需要有git和go(\u0026gt;=1.11)\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended % hugo version hugo v0.82.0+extended linux/amd64 BuildDate=unknown 创建网站 先在github上新建一个项目\n然后新建一个hugo网站项目\nhugo new site blog -f yml 初始化git，并设置默认分支名为main\ngit init git branch -m main 设置主题，这里设置PaperMod主题\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 git submodule update --init --recursive 然后生成静态网页\nhugo -d docs 上传到github\ngit add * git commit -m \u0026quot;first commit\u0026quot; git remote add origin git@github.com:MurphyWZhu/blog.git git push -u origin main 设置github\n配置网站\n下面是一些我的配置，可以根据需要修改\nbaseURL: https://murphywzhu.github.io/blog/ languageCode: zh-cn defaultContentLanguage: zh-cn title: 锦酱的博客 theme: \u0026#34;PaperMod\u0026#34; languages: zh-cn: languageName: \u0026#34;简体中文\u0026#34; weight: 1 menu: main: - name: Search url: search/ weight: 10 - name: Tags url: tags/ weight: 10 params: profileMode: enabled: true title: \u0026#34;锦酱\u0026#34; # optional default will be site title subtitle: \u0026#34;锦酱!又出Bug啦!\u0026#34; imageUrl: \u0026#34;https://mublog.oss-cn-beijing.aliyuncs.com/mutx.jpeg\u0026#34; # optional imageTitle: \u0026#34;图片被吃掉了哎!\u0026#34; # optional imageWidth: 120 # custom size imageHeight: 120 # custom size buttons: - name: 文章 url: \u0026#34;posts/\u0026#34; - name: Github url: \u0026#34;https://github.com/murphywzhu\u0026#34; outputs: home: - HTML - RSS - JSON # is necessary 然后生成并push到github上\nhugo -d docs git add * git commit -m \u0026quot;updates $(date)\u0026quot; git push -u origin main 也可以将这些步骤写成脚本\n#! /bin/bash  hugo -d docs git add * git commit -m \u0026#34;updates $(date)\u0026#34; git push -u origin main 接下来就应该可以访问了\n","permalink":"https://murphywzhu.github.io/blog/posts/hugo-00/","summary":"Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.\n Hugo是一个静态网页框架，可以快速生成网页，并且拥有许多的主题\n安装Hugo 在archlinux中\nsudo pacman -S hugo 使用源码安装\n需要有git和go(\u0026gt;=1.11)\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended % hugo version hugo v0.82.0+extended linux/amd64 BuildDate=unknown 创建网站 先在github上新建一个项目\n然后新建一个hugo网站项目\nhugo new site blog -f yml 初始化git，并设置默认分支名为main\ngit init git branch -m main 设置主题，这里设置PaperMod主题","title":"使用Hugo在github上搭建博客"},{"content":"所有权 所有权是rust的核心之一\n它有如下规则\n1、Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。 2、值在任一时刻有且只有一个所有者。 3、当所有者（变量）离开作用域，这个值将被丢弃。 变量作用域 #![allow(unused)] fn main() { { // s 在这里无效, 它尚未声明  let s = \u0026#34;hello\u0026#34;; // 从此处起，s 是有效的  // 使用 s } // 此作用域已结束，s 不再有效 } String类型 之前的类型都是栈上的，现在需要一个堆上的类型，String就是我们需要的类型\nlet s = String::from(\u0026#34;hello\u0026#34;); 对于栈上的数据rust直接复制了\nlet x = 5; let y = x; 对于堆上的数据，rust将原来的内存给了之后的，而原来的就无效了\n如下代码会错误，因为s1无效了，所以发生了无效引用\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); 如果要复制String的数据可以使用clone\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;s1 = {}, s2 = {}\u0026#34;, s1, s2); 所有权与函数 以下程序会报错\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); print_str(a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : String) { println!(\u0026#34;{}\u0026#34;, str); } 说a已经被移动了\nerror[E0382]: borrow of moved value: `a` --\u0026gt; src/main.rs:4:20 | 2 | let a = String::from(\u0026#34;Hello\u0026#34;); | - move occurs because `a` has type `String`, which does not implement the `Copy` trait 3 | print_str(a); | - value moved here 4 | println!(\u0026#34;{}\u0026#34;, a); | ^ value borrowed here after move 这是因为啊的所有权被移动到了print_str函数里，函数结束所有权就消失了\n那应该怎么办呢，不用担心，函数返回值的时候也会返回所有权，我们只需要将原来的参数返回就行\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); let b = print_str(a); println!(\u0026#34;{}\u0026#34;, b); } fn print_str(str : String) -\u0026gt; String{ println!(\u0026#34;{}\u0026#34;, str); str } 也可以像下面一样，将要返回的东西和原来的参数一起返回，不过这样着实是有些麻烦，不过我们接下来的东西可以解决\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let (s2, len) = calculate_length(s1); println!(\u0026#34;The length of \u0026#39;{}\u0026#39; is {}.\u0026#34;, s2, len); } fn calculate_length(s: String) -\u0026gt; (String, usize) { let length = s.len(); // len() 返回字符串的长度  (s, length) } 借用 像下面这样在类型前面加个\u0026amp;就是借用了，借用是不能改变值的。\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); print_str(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : \u0026amp;String){ println!(\u0026#34;{}\u0026#34;, str); } 以下程序就会报错\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); print_str(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : \u0026amp;String){ str.push_str(\u0026#34;,World!\u0026#34;); } error[E0596]: cannot borrow `*str` as mutable, as it is behind a `\u0026amp;` reference --\u0026gt; src/main.rs:8:5 | 7 | fn print_str(str : \u0026amp;String){ | ------- help: consider changing this to be a mutable reference: `\u0026amp;mut String` 8 | str.push_str(\u0026#34;,World!\u0026#34;); | ^^^ `str` is a `\u0026amp;` reference, so the data it refers to cannot be borrowed as mutable 没错，也可以像可变变量一样加个mut变成可变引用\n以下程序会输出Hello,World!\n要可以引用的话，变量本身也需要可变\nfn main() { let mut a = String::from(\u0026#34;Hello\u0026#34;); print_str(\u0026amp;mut a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : \u0026amp;mut String){ str.push_str(\u0026#34;,World!\u0026#34;); } 在特定作用域中的特定数据只能有一个可变引用。这些代码会失败：\nlet mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026#34;{}, {}\u0026#34;, r1, r2); error[E0499]: cannot borrow `s` as mutable more than once at a time --\u0026gt; src/main.rs:5:14 | 4 | let r1 = \u0026amp;mut s; | ------ first mutable borrow occurs here 5 | let r2 = \u0026amp;mut s; | ^^^^^^ second mutable borrow occurs here 6 | 7 | println!(\u0026#34;{}, {}\u0026#34;, r1, r2); | -- first borrow later used here 可以理解为一个对象只能同时存在一个可用的引用\n以下代码就可以使用\nlet mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026#34;{}\u0026#34;, r2); 因为r1在r2之后不再使用\n悬垂引用 Rust里的悬垂引用相当于其他语言里的悬垂指针，内存释放了，指针还在的意思\n以下程序会出现悬垂引用\nfn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { let s = String::from(\u0026#34;hello\u0026#34;); \u0026amp;s } error[E0106]: missing lifetime specifier --\u0026gt; src/main.rs:5:16 | 5 | fn dangle() -\u0026gt; \u0026amp;String { | ^ expected named lifetime parameter | = help: this function\u0026#39;s return type contains a borrowed value, but there is no value for it to be borrowed from help: consider using the `\u0026#39;static` lifetime | 5 | fn dangle() -\u0026gt; \u0026amp;\u0026#39;static String { | ^^^^^^^^ 因为s的作用域在{}之间，出了作用域就被释放了，这样返回的引用就变成了悬垂引用\n解决办法就是直接返回String\nfn no_dangle() -\u0026gt; String { let s = String::from(\u0026#34;hello\u0026#34;); s } ","permalink":"https://murphywzhu.github.io/blog/posts/rust-02/","summary":"所有权 所有权是rust的核心之一\n它有如下规则\n1、Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。 2、值在任一时刻有且只有一个所有者。 3、当所有者（变量）离开作用域，这个值将被丢弃。 变量作用域 #![allow(unused)] fn main() { { // s 在这里无效, 它尚未声明  let s = \u0026#34;hello\u0026#34;; // 从此处起，s 是有效的  // 使用 s } // 此作用域已结束，s 不再有效 } String类型 之前的类型都是栈上的，现在需要一个堆上的类型，String就是我们需要的类型\nlet s = String::from(\u0026#34;hello\u0026#34;); 对于栈上的数据rust直接复制了\nlet x = 5; let y = x; 对于堆上的数据，rust将原来的内存给了之后的，而原来的就无效了\n如下代码会错误，因为s1无效了，所以发生了无效引用\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); 如果要复制String的数据可以使用clone\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.","title":"Rust所有权"},{"content":"不变变量 以下程序理所当然的输出5\nfn main() { let a = 5; println!(\u0026#34;{}\u0026#34;, a); } 而当你尝试改变a的值时\nfn main() { let a = 5; a = 6; println!(\u0026#34;{}\u0026#34;, a); } 则会出现错误\nerror[E0384]: cannot assign twice to immutable variable `a` --\u0026gt; src/main.rs:3:5 | 2 | let a = 5; | - | | | first assignment to `a` | help: make this binding mutable: `mut a` 3 | a = 6; | ^^^^^ cannot assign twice to immutable variable rust会很人性化的提示你哪里错了，还会给出建议\n这就是因为rust变量默认是不可改变的，要改变的话需要声明他是可变的，就像他提示的那样\nfn main() { let mut a = 5; a = 6; println!(\u0026#34;{}\u0026#34;, a); }  常量 rust变量默认不可变，那好像和常量一样，常量不光默认不能变，它总是不能变。常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。\nconst MAX_POINTS: u32 = 100_000;  数据类型 声明 let x: i64 = 10; let x = 5.5; char类型 rust的char为四个字节，代表一个unicode标量值，所以可以使用emoji、中文字符等等\nlet c = \u0026#39;z\u0026#39;; let z = \u0026#39;ℤ\u0026#39;; let heart_eyed_cat = \u0026#39;😻\u0026#39;; 元组(tup) let tup: (i32, f64, u8) = (500, 6.4, 1); let tup = (500, 6.4, 1); println!(\u0026#34;{}\u0026#34;, tup.0); 元组默认也是不可变的，也需要加mut声明可变才可改变\nlet mut tup = (50, 6.1, 5); tup.0 = 55; 数组(array) 数组是固定长度的，一旦声明，它们的长度不能增长或缩小。\nlet a = [1, 2, 3, 4, 5]; let b: [i32; 5] = [1, 2, 3, 4, 5]; let c = [3; 5];//[3,3,3,3,3] println!(\u0026#34;{}\u0026#34;, a[0]); 数组同样也是不可变的啦，也要加mut才可改变\nlet mut list = [5, 5, 5, 5];  函数 函数是面向过程的语言里非常重要的一个东西\n在rust里的函数的定义如下\nfn func_name(x: i32) -\u0026gt; i32 { x*2 } fn func_name(x: i32) -\u0026gt; i32 { return x*2 } rust函数的最后一条表达式的值当作返回值，也可以使用return返回\nrust里只有表达式才有值，函数调用也是表达式\n 控制流 if表达式 if语句也是表达式所以也有值\n一下程序会输出20\nfn main() { let a = 10; let b = if a \u0026gt; 10 { a } else { a*2 }; println!(\u0026#34;{}\u0026#34;, b); } rust的if语句中的条件只能是值为bool型的表达式\nloop循环 fn main() { loop { println!(\u0026#34;again!\u0026#34;); } } 可以用break退出循环，loop表达式的值，即是break后面的表达式的值\n下面程序会输出20\nfn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\u0026#34;The result is {}\u0026#34;, result); } while条件循环 fn main() { let mut number = 3; while number != 0 { println!(\u0026#34;{}!\u0026#34;, number); number = number - 1; } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } for循环 fn main() { let a = [10, 20, 30, 40, 50]; for element in a.iter() { println!(\u0026#34;the value is: {}\u0026#34;, element); } } fn main() { for number in (1..4).rev() { println!(\u0026#34;{}!\u0026#34;, number); } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } ","permalink":"https://murphywzhu.github.io/blog/posts/rust-01/","summary":"不变变量 以下程序理所当然的输出5\nfn main() { let a = 5; println!(\u0026#34;{}\u0026#34;, a); } 而当你尝试改变a的值时\nfn main() { let a = 5; a = 6; println!(\u0026#34;{}\u0026#34;, a); } 则会出现错误\nerror[E0384]: cannot assign twice to immutable variable `a` --\u0026gt; src/main.rs:3:5 | 2 | let a = 5; | - | | | first assignment to `a` | help: make this binding mutable: `mut a` 3 | a = 6; | ^^^^^ cannot assign twice to immutable variable rust会很人性化的提示你哪里错了，还会给出建议","title":"Rust常见编程概念"},{"content":"Rust 据官网说介绍rust是一门高性能，高可靠的编程语言，最主要的特点就是安全可靠，据悉Linux内核都在考虑是否用rust代替C\nRust安装 可以使用官方的rustup来安装rust以及其他工具\nsudo pacman -S rustup 设置rustup的下载源\nexport RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup 安装rust\nrustup install stable rustup component add rust-src Helloworld\nCode % cargo new hello-world Created binary (application) `hello-world` package Code % cd hello-world hello-world[master*] % ls Cargo.toml src hello-world[master*] % cargo run Compiling hello-world v0.1.0 (/home/murphy/Code/hello-world) Finished dev [unoptimized + debuginfo] target(s) in 1.15s Running `target/debug/hello-world` Hello, world! Rust IDE rust还没有官方的IDE，我使用Clion的rust插件来写\n","permalink":"https://murphywzhu.github.io/blog/posts/rust/","summary":"Rust 据官网说介绍rust是一门高性能，高可靠的编程语言，最主要的特点就是安全可靠，据悉Linux内核都在考虑是否用rust代替C\nRust安装 可以使用官方的rustup来安装rust以及其他工具\nsudo pacman -S rustup 设置rustup的下载源\nexport RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup 安装rust\nrustup install stable rustup component add rust-src Helloworld\nCode % cargo new hello-world Created binary (application) `hello-world` package Code % cd hello-world hello-world[master*] % ls Cargo.toml src hello-world[master*] % cargo run Compiling hello-world v0.1.0 (/home/murphy/Code/hello-world) Finished dev [unoptimized + debuginfo] target(s) in 1.15s Running `target/debug/hello-world` Hello, world! Rust IDE rust还没有官方的IDE，我使用Clion的rust插件来写","title":"Rust初试"},{"content":"安装前配置 设置字体\nsetfont /usr/share/kbd/consolefonts/iso01-12x22.psfu.gz 连接网络\nwifi: iwctl 设置ntp\ntimedatectl set-ntp true 磁盘按照自己的需要分区\n将根目录挂载到/mnt\n修改镜像站\n","permalink":"https://murphywzhu.github.io/blog/posts/arch-install/","summary":"安装前配置 设置字体\nsetfont /usr/share/kbd/consolefonts/iso01-12x22.psfu.gz 连接网络\nwifi: iwctl 设置ntp\ntimedatectl set-ntp true 磁盘按照自己的需要分区\n将根目录挂载到/mnt\n修改镜像站","title":"Arch Install"},{"content":"这是第一篇文章\necho \u0026quot;Hello World!\u0026quot; ","permalink":"https://murphywzhu.github.io/blog/posts/hello-world/","summary":"这是第一篇文章\necho \u0026quot;Hello World!\u0026quot; ","title":"Hello World"}]